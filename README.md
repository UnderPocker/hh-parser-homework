# Pipeline, регрессия и классификация для датасета HeadHunter

Проект включает:
1. Пайплайн обработки hh.csv (Chain of Responsibility) → x_data.npy, y_data.npy
2. Регрессионная модель для предсказания зарплат
3. Классификация IT-разработчиков по уровням (junior/middle/senior) — PoC

## Установка

```bash
pip install -r requirements.txt
```

## Использование

### 1. Пайплайн (hh.csv → x_data.npy, y_data.npy)

Через единое приложение или отдельный скрипт:

```bash
python app.py path/to/hh.csv
# или
python run_pipeline.py path/to/hh.csv
```

Рядом с CSV создаются `x_data.npy` и `y_data.npy`.

### 2. Обучение модели

На вход — выход пайплайна (директория с `x_data.npy` и `y_data.npy`). Веса сохраняются в `resources/`.

```bash
python train.py path/to/data_dir
# или
python train.py --x path/to/x_data.npy --y path/to/y_data.npy
```

Опции: `--alpha` — коэффициент L2-регуляризации Ridge (по умолчанию 1.0).

### 3. Предсказание зарплат (приложение)

На вход — путь к `x_data.npy`. В stdout выводится список зарплат в рублях (float), в формате JSON.

```bash
python app.py path/to/x_data.npy
```

Пример вывода (список float в рублях):

```json
[0.708, 0.714, 0.710, ...]
```

Логи пишутся в stderr, в stdout — только JSON-список.

**Единое приложение `app.py`:** по расширению файла выбирается режим: `.csv` — пайплайн, `.npy` — предсказание.

### 4. Классификация IT-разработчиков (PoC)

Выделяет резюме IT-разработчиков, определяет уровень (junior/middle/senior), обучает классификатор и строит отчеты.

```bash
python classify.py path/to/hh.csv
```

Результаты сохраняются в `classification_results/`:
- Графики баланса классов (`class_balance.png`, `class_distribution_detailed.png`)
- Classification report (`classification_report.txt`)
- Важность признаков (`feature_importance.csv`)
- Обработанные данные (`processed_data.csv`)

---

## Анализ результатов модели классификации

Ниже — разбор результатов одного запуска `python classify.py path/to/hh.csv` на датасете hh.ru.

### Данные

- Всего резюме в датасете: **66 945**
- После фильтрации IT-разработчиков (по колонке «Ищет работу на должность»): **22 216**
- Уровень определялся по названию должности и колонке «Опыт (двойное нажатие для полной версии)»

### Баланс классов

| Уровень  | Количество | Доля   |
|----------|------------|--------|
| Junior   | 17 438     | 78.5%  |
| Middle   | 2 243      | 10.1%  |
| Senior   | 2 535      | 11.4%  |

Соотношение самого частого и самого редкого класса около **7.8 : 1** — сильный дисбаланс. Модель получает мало примеров middle/senior по сравнению с junior.

### Classification Report

```
              precision    recall  f1-score   support
      junior       0.79      0.75      0.77      3488
      middle       0.11      0.26      0.15       449
      senior       0.00      0.00      0.00       507
    accuracy                           0.62      4444
   macro avg       0.30      0.34      0.31      4444
weighted avg       0.63      0.62      0.62      4444
```

- **Junior**: precision 0.79, recall 0.75, F1 0.77 — класс предсказывается нормально.
- **Middle**: precision 0.11, recall 0.26, F1 0.15 — много ложных срабатываний и пропусков.
- **Senior**: precision и recall 0.00 — модель не предсказывает класс senior (все уходит в junior/middle).

### Confusion Matrix

```
              pred_junior  pred_middle  pred_senior
junior (3488)      2626         862            0
middle (449)        331         118            0
senior (507)        374         133            0
```

Все объекты с меткой senior модель отнесла к junior или middle; класс senior не выделяется.

### Важность признаков

В текущем запуске использовалось только **3 признака** (после подготовки данных). В `feature_importance.csv`:

1. Авто_Не указано — 0.51  
2. Авто_Имеется собственный автомобиль — 0.49  
3. Авто_nan — 0.00  

То есть модель по сути опирается на признак «наличие автомобиля», который не связан с уровнем разработчика. Остальные поля датасета в признаковое пространство не попали (или почти не попали), поэтому информации для различения junior/middle/senior недостаточно.

### Выводы о качестве модели и причинах ошибок

1. **Дисбаланс классов**  
   Junior занимает ~78% выборки. Даже с `class_weight='balanced'` модель сильнее подстраивается под доминирующий класс; middle и особенно senior предсказываются плохо.

2. **Мало признаков**  
   В обучении участвовали только 3 признака (по сути один категориальный «авто» в разных кодировках). Зарплата, город, возраст, опыт, навыки и т.п. не использовались или не попали в финальную матрицу признаков. Без них различать уровни по данным резюме невозможно.

3. **Качество и однозначность разметки**  
   Уровень задаётся эвристиками по тексту должности и опыту. Границы между junior/middle/senior размыты, возможны ошибки и неоднозначности в целевой переменной, что дополнительно снижает качество.

4. **Итог по PoC**  
   Идея автоматически различать junior/middle/senior по данным hh.ru жизнеспособна (junior неплохо отделяется), но текущая реализация — только частичный успех: accuracy 0.62, weighted F1 0.62, класс senior не предсказывается. Чтобы вывести модель на приемлемое качество по всем классам, нужно: (а) подключать больше полей из датасета (зарплата, опыт, навыки, образование и т.д.) и доработать feature engineering; (б) при необходимости балансировать классы (SMOTE, undersampling) и/или пересмотреть разметку.

---

## Структура проекта

```
Homework-5/
├── app.py              CLI: python app path/to/hh.csv (пайплайн) или path/to/x_data.npy (предсказание)
├── run_pipeline.py     Пайплайн: python run_pipeline.py path/to/hh.csv
├── train.py            Обучение регрессии: python train.py data_dir → веса в resources/
├── classify.py         Классификация IT-разработчиков: python classify.py path/to/hh.csv
├── resources/          Веса модели регрессии (model.npz) после train.py
├── model/              Модуль регрессии (Ridge)
├── pipeline/           Пайплайн Chain of Responsibility
├── classifier/         Модуль классификации IT-разработчиков
│   ├── data_processor.py    Фильтрация IT и определение уровня
│   ├── classifier_model.py  Random Forest классификатор
│   ├── visualizer.py        Визуализация баланса классов
│   └── analyzer.py          (не используется в classify.py; анализ в README)
├── requirements.txt
└── README.md
```

## Модели

### Регрессия (предсказание зарплат)
- **Ridge-регрессия** на чистом numpy
- Признаки масштабируются (zero mean, unit variance)
- Сохранение/загрузка: `resources/model.npz`

### Классификация (уровни разработчиков)
- **Random Forest** классификатор
- Обработка дисбаланса классов (`class_weight='balanced'`)
- Feature engineering: числовые признаки + one-hot encoding категориальных
- Метрики: precision, recall, F1-score по классам

## Best practices и кодстайл

- Type hints, docstrings
- Логирование
- Обработка ошибок, валидация путей и данных
- PEP 8, модульная структура
